//  工厂模式 

     class Product {
        constructor(name) {
          this.name = name;
        }
        init() {
          console.log("init");
        }
        fun() {
          console.log("fun");
        }
      }

      class Factory {
        create(name) {
          return new Product(name);
        }
      }

      // use
      let factory = new Factory();
      let p = factory.create("p1");
      p.init();
      p.fun();
    
      // 优点
      // 创建对象的过程可能很复杂，但我们只需要关心创建结果。
      // 构造函数和创建者分离, 符合“开闭原则”
      // 一个调用者想创建一个对象，只要知道其名称就可以了。
      // 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。

      // 缺点
      // 添加新产品时，需要编写新的具体产品类,一定程度上增加了系统的复杂度
      // 考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度

      // 什么时候不用
      // 当被应用到错误的问题类型上时,这一模式会给应用程序引入大量不必要的复杂性.除非为创建对象提供一个接口是我们编写的库或者框架的一个设计上目标,否则我会建议使用明确的构造器,以避免不必要的开销。
      // 由于对象的创建过程被高效的抽象在一个接口后面的事实,这也会给依赖于这个过程可能会有多复杂的单元测试带来问题。
      
      